First Command
-------------------------------------
> CTRL + T (To open Terminal)
> echo shiva
> cal
> cal 2020
> cal -y
> date
> clear
> CTRL + l
> history
> !07
> !116
> !! (to run recent cmd)
> history -c
> exit or CTRL + D (To close the terminal)
> command,terminal and shell
> Different type of shell (bhash)
> echo $PATH (To see shel path)
> shblam (Command not found) 
> which date (date command is actually located /usr/bin/date) that why the cmd is executed
> which echo (/usr/bin/echo)
> which which (/usr/bin/which)
> command option input
   date   -a -b -c -d -e -f (Order does not matter)
   date   -abcdef           (Order does not matter)
   date   --option1  --option2  --option3 (Can't chain like short form)
>  cal -A 1 12 2017 (A and B are options and have their own input 1) 12 and 2017 are input
>  cal -B 1 12 2017 (A and B are options and have their own input 1) 12 and 2017 are input
>  man -k vmstat (vmstat is search term)
>  man 8 vmstat
>  which [-a | -f] <something> (| means select one from the two optopns)
   ---which -af whis is wrong

Command Input + Output
----------------------------------
> standard Input(0) Data stream
> Srandard Output(1) Data stream
> Srandard Error(2) Data stream
> Command Arguments
> We can connect two data stream from ouput of one command to input of another command known as piping 

Redirection statndard Output
---------------------------------
> cat 1> output.txt  (overwrite the file)
> cat 1>> output.txt (append to the file)
> cat > output.txt   (other syntaxt)
> cat >> output.txt   (other syntaxt)

Redirection statndard Error
---------------------------------
> cat 2> error.txt
> cat 2>>error.txt
> cat -k bla 2>>error.txt
> cat 1>> output.txt 2>error.txt
> cat >> output.txt 2>error.txt (Other syntax you can remove 1 but still you need to mention 2 for standard error)
> cat 0< input.txt 1> hello.txt
Piping Part 1
-------------------------------
> cut date.txt  --delimiter " " --field 1
> cut date.txt  --delimiter=" " --field=1 (We can also use = )
> cut date.txt  --delimiter " " --field 1,2
> cut date.txt  --delimiter "U" --field 1 -s
> vmstat | cut  --delimiter " " --field 1,2,3,4,5,6>vmstat.txt
> date |cut --delimiter " " --fields 1 | command -option args |
> date > date.txt |cut --delimiter "" --field 1 
(Note: Here the redirection happend first so you can not pipe the output of date command to cut 
so the data can not go to two places at once. How to fix? Need to use "tee" command )
Piping Part 2
-------------------------------
> date|tee fullday.txt|cut --delimiter=" " --field=1
> date|tee fullday.txt|cut --delimiter=" " --field=1 1>today.txt
> vmstat 1 3|tee vmstat.txt| cut --delimiter=" " --field=1,2 1>process.txt 
 Key Point:
  1. Once you redirect the pipeline you can not continue
  2. If you want to continue the pipline use "tee" command

Piping Part 3 Using xargs
-----------------------------------
Part 1>>>>> Piping is all about connection the standard out of one command 
	    to standard input of another command 
Part 2>>>>> How you can pass data through your pipeline but also take snapshot 
	    of the data as it flows through and save that snapshot into a file using "tee' command
Part 3>>>>> Piping is all about connection the standard out of one command to standard input
	    of another command . No all command accept standard input some only accepts command line arguments.
            And to handle this scenario "xargs" comes in. The "xargs" allows you to convert the pipes data into 
	    command line arguments for the commands that only accept arguments. So that you can 
            keep your pipe going withou breaking 
            
	    xargs - will conver the data from standard input into command line argument

> date |xargs echo
> date |xargs echo "hello"
> date |cut --delimiter=" " --field=1|xargs echo
> cat deletelist.txt |xargs rm

Aliases
-----------------------------------
To be updated once reach home and using the laptop


Linux File System
----------------------------------------
1. Everything in linux start from root
2. No harddisk partision

Navigating File System part 1
------------------------------------------
> pwd
> ~  (Represent the current user home directory)
> ls (list directory content. 
      Note: ls cant accept standard input so you can't pipe it. In "ls" everything is command line arguments

> ls /home/karthik
> ls ~
> ks -F (different between files and folder/ )
> ls -F>list.txt
> ls -l (long form format)
> ls -lh (human readable form about file size)
> ls -la (x-ray --show all file in the file directory including the hidden file)
> ls /etc /home /bin  (It list file from etc home bin directory in one go. But better use wild card )
> ls >out.txt 
> ls {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2017..2022}>out.txt

Navigating File System part 2
------------------------------------------
> cd /home/ziyad/downloads
> cd ~/downloads
> cd ~/Desktop
> cd (This will take you to the home directory no matter whereever your are in the file system)
> cd . (refer the current folder)
> cd .. (go back to one level up to the parant folder)
> cd /  (This will take you to the base/root directory no matter whereever you are in the file system)

Navigating File System part 3
------------------------------------------
1. Learn aout Tab and double Tab to auto completion
2. Go to the path using GUI and right-click and click open in terminal

File Extensions in Linux
--------------------------------------------
1. In Linux file extension don't matter. Unlike windows, Linux does't determine file type using the file extension.
   But instead linux read a piece of code inside at the top of the file. And that piece of code is known as header.
   An it serves as label for linux to read. Linux read that label and it knows the file type. So just change the file extension 
   dont change that header.

   Note: The programms that are installed on top of the operating system PDF viewer or Libra Office and stuff like that they need file to have 
         specific extension inorder to open them. But operating system itself does not care. 

[xxxxxxxxx]# file rms-logs_5thOct.txt
rms-logs_5thOct.txt: UTF-8 Unicode text
[xxxxxxxxx]# file uams_namespace_def.yml
uams_namespace_def.yml: ASCII text
[xxxxxxxxx]# file poi.json
poi.json: empty
[xxxxxxxxxx]# file nugetv3_workaround.sh
nugetv3_workaround.sh: Bourne-Again shell script, ASCII text executable

Wildcards 
------------------------------------------
1. * match anything regardless of length
2. ? match anything but the length is one
3. [] restict what has to go inside. ls file[1234567890].txt
4. [0-9][a-z][A-Z]


> ls /etc /home /bin 
> ls * (Very powerfull command to see all the files in root to get quick over about the system)
> ls *.txt
> ls file?.txt
> ls file[1234567890].txt
> ls file[0-9][A-z][a-z].txt
> ls file[0-9ABC].txt
> ls file[0-9abc].txt

Creating Files and Directories Part 1
--------------------------------------
> touch file1
> touch ~/Document/distantfile
> echo "Hello" > hello.txt


> mkdir newfolder
> mkdir ~/Pictires/Holiday

> mkdir -p bla/thing/shiblam (P option will create the entire path)
> mkdir happy birthday (Dont use space in naming folder and file instead use "_" )

Creating Files and Directories Part 2 (Power of braces {})
--------------------------------------
> mkdir {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2017,2018,2019,2020,2021,2022}
> mkdir {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2017..2022}
> touch {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2017..2022}/file{1..100}

> mkdir -p delfolder/deleteme{1,2,3} 
> touch delfolder/deleteme{1,2,3}/file{1,2,3}

> This slide needs to be revisited to create file inside the folder
> ls {jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec}_{2017..2022}>out.txt
> ls >out.txt
> touch file{A,B,C}.txt
> touch file{A..C}.txt
> touch file{1..100}.txt

Deleting Files and Folders (Part 1)
-----------------------------------
> rm deleteme
> rm Documents/deleteme
> rm file1.txt Document/file2.txt /Download/file3.txt

> rm *.txt
> rm file*
> rm *2*
> rm *.jpg
> rm *[2,3]*

Deleting Files and Folders (Part 2)
-----------------------------------
> rm -r Deletefolder
> mkdir delfolder/delitem{1,2,3}
> rm -ri deletefolder
> rmdir (remove all empty folder)
> rmdir delfolder/* (remove everything in delfolder which is empty. so folder 1 & 2 stay and folder 3 will be removed)

Copy and Past File
------------------------------------
> cp file1.txt file2.txt
> cp file1.txt file2.txt destination/
> cp destination/* .
> cp -r copymefolder/ destination (Copy and Past the folde to destination)

Moving and Renaming files and Directoties
-----------------------------------------
> mv oldfile.txt newfile.txt
> mv oldefolder/ newfolder
> mv newfolder/ /home/copyme
> mv newfilder/ ~/Documents/
> mv ~/Documents/newfolder ./jackpot (Move the rename folder and also rename the folder as jackpot)

Editing Files usnin nano (Part - 1)
-----------------------------------
How to install nano
> apt-get update
> apt-get install nano
> nano dairy.txt
> ^ symbol means CTRL
> M symbol means ATL

we see the writeout option
we see the readfile option
we see the whereis option
we see the replace option

Editing Files usnin nano (Part - 2)
-----------------------------------

setup the spell check in nano

> nano /etc/nanorc

search the below text using wheris option ^W
#set speller "aspell -x -c"

remove the # symbole and remove the leading space and writeout/save the file
set speller "aspell -x -c"

The Locate Command - Part 1
---------------------------------
> locate *.conf
> locate -i *.conf (search based on case insensetive search)
> locate -i --limit 3 *.conf (limite the output to 3 results)
> locate -i --limit 5 *.conf (limite the output to 5 results)
> locate -i --limit 10 *.conf (limite the output to 10 results)
> locate -S (To get the information about the database) 
> locate -S > ~/Desktop/database_before.txt
> locate -e *.conf (-e option will check the file is exist or not before reporting)
> locate --existing *.conf (-e option will check the file is exist or not before reporting)
> locate --follow *.conf
> locate --existing --follow -i --limit 5 *.conf

The Locate Command - Part 2 (Update DB)
---------------------------------------
> sudo updatedb
> locate test.txt
> locate -S >database_after.txt


The Find Command part -1 
-------------------------
Difference between Locat and Find

1. Find command list out the files and folders. But the list command only list the files
2. Find command does not need the database to work. But the locat command the database and it should be always upto date 
3. Find command not use the database and it operate directly on file system. So it will be bit slow compare to locate command
3. Find command will search deeper and deper with infinite dept. It start with the current directory or whereever you give it 


> find (list every file and folder in our home directory and below it)
> find / (Pls dont run it will slow your sysyem)
> find /etc
> find /home/ziyad/Documents
> find /home/

The Find Command part -2
--------------------------

1. How to control the search depth
> find . -maxdepth 1
> find . -maxdepth 2
> find . -maxdepth 3
> find . -maxdepth 4
> find . -maxdepth 5

By default find comand list both files and folder. if you only want the files use "-type f" option.if you only want the files use "-type d" option.
> find . -type f
> find . -type d
> find . -maxdepth 1 -type d 
> find . -maxdepth 2 -type d 
> find . -maxdepth 3 -type d 
> find . -maxdepth 4 -type d 
> find . -maxdepth 5 -type d 

> find . -maxdepth 1 -type f
> find . -maxdepth 2 -type f 
> find . -maxdepth 3 -type f 
> find . -maxdepth 4 -type f 
> find . -maxdepth 5 -type f

> find /etc -maxdepth1 type f


The Find Command part -3 (search file using name)
--------------------------------------------------
> find . -name "*5.txt"
> find . -name "*.txt"
> find . -maxdepth 2 -name "*.txt"
  Note: You can not use brace {} expansion inside the name option. Just a side note
> find . -maxdepth 2 -iname "*.TXT" (Case insensetive search)

> find / -type f -size +100k
> find / -type f -size -100k
> find / -type f -size +100k |wc -l
> find / -type f -size -100k |wc -l
> find / -type f -size +100k -size -5M|wc -l
> find / -type f -size -100k -o -size -5M|wc -l


The Find Command Part -4 (use -exe and -ok option )
-----------------------------------------------------
> find / -type f -size +10k -size -500M  -exec cp {} ./copy_here \; (this command will copy the files to copy_here folders
> find / -type f -maxdepth 4 -size +10k -size -500M  -exec cp {} ./copy_here \; (this command will copy the files to copy_here folders
> find / -type f -maxdepth 4 -size +10k -size -500M  -ok cp {} ./copy_here \; (This ok option will ask confirmation for every file. press Yes or No. If you want to cancel press CTRL+C)

The Find Command Part -5 (Find the needle from haystack)
-------------------------------------------------------------
> touch haystack/folder$(shuf -i 1-50 -n l)/needle.txt (This command is not working need to revisit)
> find -type f -name "needle.txt"
> find -type f -name "needle.txt" -exec mv WHAT WHERE \;
> find haystack/ -type f -name "needle.txt" -exec mv {}  ./home/copy_here \;







 
















                                                                                                                                                                                                                           





   


